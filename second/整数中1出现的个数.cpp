//求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？
//为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。
//ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。

class Solution {
public:
    int NumberOf1Between1AndN_Solution(int n)
    {
   	int result=0,sum=0,std=1,i=n;
	while(i/std){
		int temp=i/(std*10);
		int num_bit=(i%(std*10))/std;
		if(num_bit==0) sum=temp*std;
		else if(num_bit==1) sum=temp*std+i%std+1;
		else 
			sum=(temp+1)*std;
		result=result+sum;
		std=std*10;
		sum=0;
	}
	return result;
    }
};
/*

复杂度为O(len），len表示数n包含的数字个数。

方法：

假设数字为abcde，对于abcde中的每一个数字，可以根据该数字与1的关系，求在该数字对应位置上1出现的次数。

具体来说：

假设我们要求百位出现1的次数，此时我们可以根据c与1的关系，求出百位1出现的次数。

（1）如果c = 0，则1出现的次数等于ab * 100，即 c前面的数 * c对应的基数

在该情况下，百位出现1的次数只与c前面的数有关。

（2）如果c = 1，则1出现的次数等于（ab * 100） + （de + 1），即（c前面的数 * c对应的基数） +（ c后面的数 + 1）

在该情况下，百位出现1的次数与c前面和c后面的数有关。

（3）如果c = 2，则1出现的次数等于（ab + 1）*100，即（c前面的数 +1）* c对应的基数

在该情况下，百位出现1的次数只与c前面的数有关。

举例：

对于12013，在百位处出现1的次数= 12 * 100 = 1200次

其分别是，00100 -00199,01100 -01199,02100 - 02199,...,11100 - 11199。

（1）由于因为百位 = 0，则以12为开头的数不会含有1。

（2）百位前面的数值能有00 - 11，即出现12次。由于百位后的数字有两位，因此其基数为100。

即，以00 - 11为开头的数，后面都可以由00 变化到99，即包含了所有1的情况。

--------------------------------------


对于12113，在百位处出现1的次数= （12 * 100 ） + （13+1）= 1214次

（1）包含足够1的情况：00100 - 00199,01100 - 01199,02100 - 02199,...,11100 - 11199

（2）包含部分1的情况：12100 - 12113
即，由于百位 = 1，则以00 - 12为开头的数在百位都含有1。

（1）当百位前面的数字为00-11时，此情况包含了所有1的情况。（00-99）

（2）当百位前面为数字为12时，此情况仅仅包含了部分1的情况（00-13）

---------------------------------------

对于12213，在百位处出现1的次数= （12+1） * 100 = 1300次

其分别是，00100 - 00199,01100 - 01199,02100 - 02199,...,11100 - 11199，12100 - 12199。
此时，百位前面的数无论怎么变化，后面都可以由00 变化到99，即包含了所有1的情况。
*/
